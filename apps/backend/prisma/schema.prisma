// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Scope {
  habitos
  tareas
  eventos
  gastos
}

enum HabitType {
  CHECK
  NUMERIC
}

enum Periodicity {
  DAILY
  WEEKLY
  MONTHLY
  CUSTOM
}

enum TimeOfDay {
  AYUNO
  MANANA
  MEDIA_MANANA
  TARDE
  MEDIA_TARDE
  NOCHE
  ANTES_DORMIR
  ANYTIME
}

enum ChangeType {
  CREATED
  UPDATED
  DELETED
  REACTIVATED
}

enum Priority {
  alta
  media
  baja
}

enum TaskStatus {
  pendiente
  en_progreso
  completada
  cancelada
}

enum EventStatus {
  pendiente
  completado
  cancelado
}

enum AccountType {
  efectivo
  banco
  billetera_digital
  tarjeta
}

enum TransactionType {
  ingreso
  egreso
}

enum ExpenseStatus {
  pendiente
  pagado
}

enum DevicePlatform {
  IOS
  ANDROID
  WEB
}

enum WeightUnit {
  kg
  lbs
}

enum MuscleGroup {
  pecho
  espalda
  piernas
  hombros
  brazos
  core
  cardio
  otro
}

model User {
  id                   String                   @id @default(uuid())
  email                String                   @unique
  name                 String
  password             String
  refreshToken         String?
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  categories           Category[]
  habits               Habit[]
  habitRecords         HabitRecord[]
  habitAudits          HabitAudit[]
  notificationSettings NotificationSetting[]
  tasks                Task[]
  events               Event[]
  syncSetting          SyncSetting?
  accounts             Account[]
  transactions         Transaction[]
  recurringExpenses    RecurringExpense[]
  monthlyExpenses      MonthlyExpenseInstance[]
  pushTokens           PushToken[]
  notifications        Notification[]
  exercises            Exercise[]
  routines             Routine[]
  workouts             Workout[]

  @@index([email])
  @@map("users")
}

model Category {
  id        String   @id @default(uuid())
  userId    String
  name      String
  scope     Scope
  icon      String?
  color     String?
  isDefault Boolean  @default(false)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  habits                  Habit[]
  tasks                   Task[]
  events                  Event[]
  transactions            Transaction[]
  monthlyExpenseInstances MonthlyExpenseInstance[]

  @@unique([userId, name, scope])
  @@index([userId, scope])
  @@map("categories")
}

model Habit {
  id                String      @id @default(uuid())
  userId            String
  categoryId        String
  name              String
  description       String?
  type              HabitType
  targetValue       Int?
  unit              String?
  periodicity       Periodicity @default(DAILY)
  weekDays          Int[]       @default([])
  timeOfDay         TimeOfDay   @default(ANYTIME)
  reminderTime      String?
  color             String?
  order             Int         @default(0)
  isActive          Boolean     @default(true)
  currentStreak     Int         @default(0)
  longestStreak     Int         @default(0)
  lastCompletedDate DateTime?   @db.Date
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  category            Category             @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  records             HabitRecord[]
  audits              HabitAudit[]
  notificationSetting NotificationSetting?

  @@index([userId, isActive])
  @@index([categoryId])
  @@index([userId, lastCompletedDate])
  @@index([userId, createdAt(sort: Desc)])
  @@map("habits")
}

/// HabitRecord: Registro hist贸rico de completitudes de h谩bitos
/// Sprint 4 - US-028
///
/// Este modelo registra cada completitud diaria de un h谩bito por un usuario.
/// Permite calcular rachas, estad铆sticas y mantener historial completo.
///
/// Restricciones:
/// - Un h谩bito solo puede tener un registro por d铆a (unique index)
/// - El campo `value` es para h谩bitos NUMERIC (ej: 74.5 kg, 5 km)
/// - El campo `completed` indica si se cumpli贸 el objetivo del d铆a
/// - El campo `notes` es opcional para observaciones del usuario
model HabitRecord {
  id        String   @id @default(uuid())
  habitId   String
  userId    String
  date      DateTime @db.Date
  completed Boolean  @default(false)
  value     Float?
  notes     String?  @db.VarChar(500)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  habit Habit @relation(fields: [habitId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([habitId, userId, date])
  @@index([userId, date])
  @@index([habitId, date(sort: Desc)])
  @@map("habit_records")
}

/// HabitAudit: Registro de auditor铆a para trazabilidad de cambios en h谩bitos
/// Sprint 6 - US-046
///
/// Este modelo registra todos los cambios realizados a un h谩bito para mantener
/// un historial completo de modificaciones (creaci贸n, actualizaci贸n, eliminaci贸n, reactivaci贸n).
///
/// Campos:
/// - changeType: Tipo de cambio (CREATED, UPDATED, DELETED, REACTIVATED)
/// - fieldChanged: Nombre del campo modificado (null para CREATED/DELETED completos)
/// - oldValue: Valor anterior del campo (JSON string, null para CREATED)
/// - newValue: Valor nuevo del campo (JSON string, null para DELETED)
/// - reason: Raz贸n del cambio (opcional, 煤til para eliminaciones/reactivaciones)
///
/// ndices:
/// - (habitId, createdAt DESC): Para consultar historial de un h谩bito ordenado
/// - userId: Para auditor铆as por usuario
model HabitAudit {
  id           String     @id @default(uuid())
  habitId      String
  userId       String
  changeType   ChangeType
  fieldChanged String?    @db.VarChar(100)
  oldValue     String?    @db.Text
  newValue     String?    @db.Text
  reason       String?    @db.VarChar(500)
  createdAt    DateTime   @default(now())

  habit Habit @relation(fields: [habitId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([habitId, createdAt(sort: Desc)])
  @@index([userId])
  @@map("habit_audits")
}

/// NotificationSetting: Configuraci贸n de notificaciones por h谩bito
/// Sprint 6 - US-050
///
/// Este modelo almacena la configuraci贸n de recordatorios para cada h谩bito.
/// Permite al sistema enviar notificaciones push en el momento adecuado.
///
/// Campos:
/// - habitId: Relaci贸n 1:1 con Habit (UNIQUE constraint)
/// - userId: Usuario propietario (para queries r谩pidas en cron jobs)
/// - enabled: Si las notificaciones est谩n habilitadas para este h谩bito
/// - time: Hora del recordatorio en formato "HH:mm" (ej: "08:00", "20:30")
///
/// Restricciones:
/// - UNIQUE en habitId: Un h谩bito solo puede tener una configuraci贸n de notificaci贸n
/// - ON DELETE CASCADE: Si se elimina el h谩bito, se elimina su configuraci贸n
///
/// ndices:
/// - (userId, enabled): Para cron job que busca notificaciones habilitadas por usuario
model NotificationSetting {
  id        String   @id @default(uuid())
  habitId   String   @unique
  userId    String
  enabled   Boolean  @default(true)
  time      String   @db.VarChar(5)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  habit Habit @relation(fields: [habitId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, enabled])
  @@map("notification_settings")
}

/// Task: Modelo de tareas con soporte para checklists
/// Sprint 7 - US-056
///
/// Este modelo representa una tarea con todas sus propiedades, incluyendo
/// prioridad, estado, fechas de vencimiento y completitud, y categorizaci贸n.
///
/// Campos principales:
/// - title: T铆tulo de la tarea (max 200 caracteres)
/// - description: Descripci贸n detallada (texto, opcional)
/// - priority: Prioridad (alta, media, baja) - default: media
/// - status: Estado actual (pendiente, en_progreso, completada, cancelada) - default: pendiente
/// - dueDate: Fecha de vencimiento (opcional)
/// - completedAt: Fecha y hora de completitud (se setea autom谩ticamente al completar)
/// - canceledAt: Fecha y hora de cancelaci贸n (se setea autom谩ticamente al cancelar)
/// - archivedAt: Fecha y hora de archivado (para auto-archivado de tareas antiguas)
/// - cancelReason: Raz贸n de cancelaci贸n (opcional, max 200 caracteres)
/// - orderPosition: Posici贸n para ordenamiento custom por usuario
/// - isActive: Flag para soft delete
///
/// Relaciones:
/// - category: Relaci贸n con Category de scope 'tareas' (ON DELETE RESTRICT)
/// - user: Relaci贸n con User (ON DELETE CASCADE)
/// - checklistItems: Lista de items del checklist (ON DELETE CASCADE)
///
/// ndices:
/// - (userId, isActive, status): Para queries de listado de tareas activas
/// - (userId, dueDate): Para filtros y ordenamiento por fecha de vencimiento
model Task {
  id            String     @id @default(uuid())
  userId        String
  categoryId    String
  title         String     @db.VarChar(200)
  description   String?    @db.Text
  priority      Priority   @default(media)
  status        TaskStatus @default(pendiente)
  dueDate       DateTime?
  completedAt   DateTime?
  canceledAt    DateTime?
  archivedAt    DateTime?
  cancelReason  String?    @db.VarChar(200)
  isActive      Boolean    @default(true)
  orderPosition Int        @default(0)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  category       Category            @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  checklistItems TaskChecklistItem[]

  @@index([userId, isActive, status])
  @@index([userId, dueDate])
  @@index([userId, createdAt(sort: Desc)])
  @@index([categoryId])
  @@map("tasks")
}

/// TaskChecklistItem: Items de checklist para tareas
/// Sprint 7 - US-056
///
/// Este modelo representa los items individuales de un checklist asociado a una tarea.
/// Permite crear sub-tareas o pasos que deben completarse como parte de una tarea mayor.
///
/// Campos:
/// - taskId: Relaci贸n con Task padre (ON DELETE CASCADE)
/// - title: T铆tulo del item (max 200 caracteres)
/// - completed: Estado de completitud del item (default: false)
/// - position: Posici贸n para ordenamiento dentro del checklist
///
/// Relaciones:
/// - task: Relaci贸n con Task padre (ON DELETE CASCADE - si se elimina la tarea, se eliminan sus items)
///
/// ndices:
/// - (taskId, position): Para queries ordenadas del checklist de una tarea
model TaskChecklistItem {
  id        String   @id @default(uuid())
  taskId    String
  title     String   @db.VarChar(200)
  completed Boolean  @default(false)
  position  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId, position])
  @@map("task_checklist_items")
}

/// Event: Modelo de eventos de calendario con sincronizaci贸n Google
/// Sprint 8 - US-065
///
/// Este modelo representa eventos de calendario con soporte para eventos recurrentes,
/// sincronizaci贸n con Google Calendar y notificaciones.
///
/// Campos principales:
/// - title: T铆tulo del evento (max 200 caracteres)
/// - description: Descripci贸n detallada (texto, opcional)
/// - location: Ubicaci贸n del evento (max 200 caracteres, opcional)
/// - startDateTime: Fecha y hora de inicio
/// - endDateTime: Fecha y hora de fin
/// - isAllDay: Flag para eventos de d铆a completo (default: false)
/// - isRecurring: Flag para eventos recurrentes (default: false)
/// - rrule: Regla de recurrencia en formato RFC 5545 (opcional, para eventos recurrentes)
/// - recurringEventId: ID del evento padre si es instancia de evento recurrente (self-relation)
/// - status: Estado del evento (pendiente, completado, cancelado) - default: pendiente
/// - completedAt: Fecha y hora de completitud
/// - canceledAt: Fecha y hora de cancelaci贸n
/// - archivedAt: Fecha y hora de archivado
/// - syncWithGoogle: Flag para sincronizar con Google Calendar (default: true)
/// - googleEventId: ID del evento en Google Calendar (unique)
/// - reminderMinutes: Minutos antes del evento para enviar recordatorio (opcional)
/// - notificationSent: Flag que indica si la notificaci贸n ya fue enviada (default: false)
///
/// Relaciones:
/// - category: Relaci贸n con Category de scope 'eventos' (ON DELETE RESTRICT)
/// - user: Relaci贸n con User (ON DELETE CASCADE)
/// - recurringEvent: Self-relation para eventos recurrentes (ON DELETE CASCADE)
/// - instances: Instancias de eventos recurrentes (ON DELETE CASCADE)
///
/// ndices:
/// - (userId, startDateTime, endDateTime): Para queries de rango de fechas
/// - (googleEventId): nico para sincronizaci贸n
/// - (userId, status, archivedAt): Para filtros de eventos activos
/// - (userId, syncWithGoogle): Para job de sincronizaci贸n con Google
model Event {
  id               String      @id @default(uuid())
  userId           String
  categoryId       String
  title            String      @db.VarChar(200)
  description      String?     @db.Text
  location         String?     @db.VarChar(200)
  startDateTime    DateTime
  endDateTime      DateTime
  isAllDay         Boolean     @default(false)
  isRecurring      Boolean     @default(false)
  rrule            String?     @db.Text
  recurringEventId String?
  status           EventStatus @default(pendiente)
  completedAt      DateTime?
  canceledAt       DateTime?
  archivedAt       DateTime?
  syncWithGoogle   Boolean     @default(true)
  googleEventId    String?     @unique @db.VarChar(255)
  syncRetryCount   Int         @default(0)
  syncNextRetryAt  DateTime?
  syncLastError    String?     @db.Text
  reminderMinutes  Int?
  notificationSent Boolean     @default(false)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category       Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  recurringEvent Event?   @relation("RecurringEvents", fields: [recurringEventId], references: [id], onDelete: Cascade)
  instances      Event[]  @relation("RecurringEvents")

  @@index([userId, startDateTime, endDateTime])
  @@index([userId, status, archivedAt])
  @@index([userId, syncWithGoogle])
  @@index([startDateTime, notificationSent])
  @@index([categoryId])
  @@map("events")
}

/// SyncSetting: Configuraci贸n de sincronizaci贸n con Google Calendar por usuario
/// Sprint 8 - US-065
///
/// Este modelo almacena la configuraci贸n de sincronizaci贸n con Google Calendar
/// para cada usuario, incluyendo tokens de autenticaci贸n OAuth2.
///
/// Campos:
/// - userId: Relaci贸n 1:1 con User (UNIQUE constraint)
/// - googleCalendarEnabled: Si la sincronizaci贸n est谩 habilitada (default: false)
/// - googleAccessToken: Token de acceso OAuth2 de Google (encrypted, nullable)
/// - googleRefreshToken: Token de refresh OAuth2 de Google (encrypted, nullable)
/// - googleTokenExpiresAt: Fecha y hora de expiraci贸n del access token
/// - lastSyncAt: Fecha y hora de la 煤ltima sincronizaci贸n exitosa
///
/// Restricciones:
/// - UNIQUE en userId: Un usuario solo puede tener una configuraci贸n de sincronizaci贸n
/// - ON DELETE CASCADE: Si se elimina el usuario, se elimina su configuraci贸n
///
/// Seguridad:
/// - Los tokens de Google deben ser encriptados en la capa de aplicaci贸n antes de guardar
/// - Usar prisma-field-encryption o similar para encriptaci贸n transparente
///
/// ndices:
/// - userId (unique): Para lookup r谩pido de configuraci贸n por usuario
model SyncSetting {
  id                    String    @id @default(uuid())
  userId                String    @unique
  googleCalendarEnabled Boolean   @default(false)
  googleAccessToken     String?   @db.Text
  googleRefreshToken    String?   @db.Text
  googleTokenExpiresAt  DateTime?
  lastSyncAt            DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sync_settings")
}

/// Account: Modelo de cuentas financieras
/// Sprint 9 - US-073
///
/// Este modelo representa cuentas bancarias, efectivo, billeteras digitales y tarjetas
/// donde el usuario gestiona su dinero. Cada cuenta tiene un balance inicial y actual
/// que se actualiza con cada transacci贸n.
///
/// Campos principales:
/// - name: Nombre de la cuenta (ej: "Banco Galicia", "Efectivo", "Mercado Pago")
/// - type: Tipo de cuenta (efectivo, banco, billetera_digital, tarjeta)
/// - currency: C贸digo de moneda ISO 4217 (ARS, USD, EUR, etc.)
/// - initialBalance: Balance inicial de la cuenta al momento de crearla
/// - currentBalance: Balance actual (se actualiza autom谩ticamente con transacciones)
/// - color: Color hexadecimal para identificaci贸n visual en UI (ej: "#3B82F6")
/// - icon: Emoji para identificaci贸n visual (ej: "", "", "")
/// - isActive: Flag para soft delete (default: true)
///
/// Relaciones:
/// - user: Relaci贸n con User (ON DELETE CASCADE)
/// - transactions: Lista de transacciones de esta cuenta (ON DELETE RESTRICT)
/// - targetTransactions: Transacciones donde esta cuenta es destino de transferencia
///
/// ndices:
/// - (userId, isActive): Para queries de cuentas activas por usuario
///
/// Restricciones:
/// - No se puede eliminar una cuenta si tiene transacciones (ON DELETE RESTRICT)
/// - Se debe usar soft delete (isActive = false) en su lugar
model Account {
  id             String      @id @default(uuid())
  userId         String
  name           String      @db.VarChar(100)
  type           AccountType
  currency       String      @db.VarChar(3)
  initialBalance Decimal     @db.Decimal(15, 2)
  currentBalance Decimal     @db.Decimal(15, 2)
  color          String      @db.VarChar(7)
  icon           String      @db.VarChar(10)
  isActive       Boolean     @default(true)
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions            Transaction[]            @relation("AccountTransactions")
  targetTransactions      Transaction[]            @relation("TargetAccountTransactions")
  monthlyExpenseInstances MonthlyExpenseInstance[]

  @@index([userId, isActive])
  @@map("accounts")
}

/// Transaction: Modelo de transacciones financieras
/// Sprint 9 - US-073
///
/// Este modelo representa ingresos, egresos y transferencias entre cuentas.
/// Cada transacci贸n afecta el balance de una cuenta (y opcionalmente otra en transferencias).
///
/// Campos principales:
/// - accountId: Cuenta desde donde se realiza la transacci贸n
/// - categoryId: Categor铆a del gasto/ingreso (scope 'gastos')
/// - userId: Usuario propietario (denormalizado para queries r谩pidas)
/// - type: Tipo de transacci贸n (ingreso o egreso)
/// - amount: Monto de la transacci贸n (siempre positivo, > 0)
/// - concept: Descripci贸n breve de la transacci贸n (max 200 caracteres)
/// - date: Fecha y hora de la transacci贸n
/// - notes: Notas adicionales opcionales
/// - isTransfer: Flag que indica si es una transferencia entre cuentas
/// - targetAccountId: ID de cuenta destino (solo si isTransfer = true)
/// - transferPairId: ID de la transacci贸n vinculada (para transferencias bidireccionales)
///
/// Relaciones:
/// - account: Cuenta de origen (ON DELETE RESTRICT)
/// - targetAccount: Cuenta destino si es transferencia (ON DELETE RESTRICT)
/// - category: Categor铆a del gasto/ingreso (ON DELETE RESTRICT)
/// - user: Usuario propietario (ON DELETE CASCADE)
///
/// ndices:
/// - (accountId, date): Para listar transacciones de una cuenta ordenadas por fecha
/// - (userId, date): Para listar todas las transacciones del usuario ordenadas
/// - (transferPairId): Para buscar la transacci贸n vinculada en transferencias
///
/// Restricciones:
/// - amount > 0: El monto debe ser positivo (constraint a nivel de base de datos)
/// - No se puede eliminar una cuenta si tiene transacciones (RESTRICT)
///
/// Transferencias:
/// Las transferencias crean DOS transacciones:
/// 1. Egreso en cuenta origen (type=egreso, targetAccountId=destino)
/// 2. Ingreso en cuenta destino (type=ingreso, accountId=destino)
/// Ambas comparten el mismo transferPairId para poder vincularlas
model Transaction {
  id              String          @id @default(uuid())
  accountId       String
  categoryId      String
  userId          String
  type            TransactionType
  amount          Decimal         @db.Decimal(15, 2)
  concept         String          @db.VarChar(200)
  date            DateTime
  notes           String?         @db.Text
  isTransfer      Boolean         @default(false)
  targetAccountId String?
  transferPairId  String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  account       Account  @relation("AccountTransactions", fields: [accountId], references: [id], onDelete: Restrict)
  targetAccount Account? @relation("TargetAccountTransactions", fields: [targetAccountId], references: [id], onDelete: Restrict)
  category      Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([accountId, date])
  @@index([userId, date])
  @@index([userId, type, date])
  @@index([transferPairId])
  @@index([categoryId])
  @@map("transactions")
}

/// RecurringExpense: Plantilla de gasto recurrente mensual
/// Sprint 10 - US-083
///
/// Este modelo representa una plantilla de gasto recurrente (ej: alquiler, servicios).
/// No almacena el monto real, solo el concepto y categor铆a.
/// Se usa para generar MonthlyExpenseInstance cada mes.
model RecurringExpense {
  id         String   @id @default(uuid())
  userId     String
  concept    String   @db.VarChar(200)
  categoryId String
  currency   String   @db.VarChar(3)
  dueDay     Int?     /// D铆a del mes en que vence (1-31), null si no tiene vencimiento fijo
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  monthlyExpenseInstances MonthlyExpenseInstance[]

  @@index([userId, isActive])
  @@map("recurring_expenses")
}

/// MonthlyExpenseInstance: Instancia mensual de gasto recurrente
/// Sprint 10 - US-083
///
/// Este modelo representa una instancia espec铆fica de un gasto recurrente para un mes determinado.
/// Almacena el monto real del mes, estado de pago, cuenta utilizada, etc.
/// Se genera autom谩ticamente cada mes a partir de RecurringExpense.
model MonthlyExpenseInstance {
  id                 String        @id @default(uuid())
  recurringExpenseId String
  userId             String
  month              Int
  year               Int
  concept            String        @db.VarChar(200)
  categoryId         String
  amount             Decimal       @db.Decimal(15, 2)
  previousAmount     Decimal?      @db.Decimal(15, 2)
  accountId          String?
  paidDate           DateTime?
  status             ExpenseStatus @default(pendiente)
  notes              String?       @db.Text
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  recurringExpense RecurringExpense @relation(fields: [recurringExpenseId], references: [id], onDelete: Cascade)
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  category         Category         @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  account          Account?         @relation(fields: [accountId], references: [id], onDelete: SetNull)

  @@unique([recurringExpenseId, month, year])
  @@index([userId, month, year, status])
  @@index([recurringExpenseId])
  @@map("monthly_expense_instances")
}

/// PushToken: Tokens de dispositivos para notificaciones push
/// Sprint 12 - US-105
///
/// Este modelo almacena los tokens FCM/APNs de los dispositivos de los usuarios
/// para enviar notificaciones push. Un usuario puede tener m煤ltiples dispositivos.
///
/// Campos:
/// - userId: Usuario propietario del dispositivo
/// - token: Token FCM/APNs (UNIQUE - un token solo puede pertenecer a un usuario)
/// - platform: Plataforma del dispositivo (IOS, ANDROID, WEB)
/// - deviceName: Nombre del dispositivo (ej: "iPhone 12", "Samsung Galaxy S21")
/// - deviceId: Identificador 煤nico del dispositivo (opcional)
/// - appVersion: Versi贸n de la app instalada (ej: "1.0.0")
/// - active: Si el token est谩 activo (se desactiva si FCM reporta token inv谩lido)
/// - lastUsedAt: ltima vez que se us贸 el token para enviar notificaci贸n
///
/// Restricciones:
/// - UNIQUE en token: Un token solo puede pertenecer a un dispositivo
/// - ON DELETE CASCADE: Si se elimina el usuario, se eliminan sus tokens
///
/// ndices:
/// - (userId, active): Para queries de tokens activos por usuario
/// - token (unique): Para validaci贸n r谩pida de tokens
model PushToken {
  id         String         @id @default(uuid())
  userId     String
  token      String         @unique @db.VarChar(500)
  platform   DevicePlatform
  deviceName String?        @db.VarChar(100)
  deviceId   String?        @db.VarChar(100)
  appVersion String?        @db.VarChar(20)
  active     Boolean        @default(true)
  lastUsedAt DateTime?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, active])
  @@map("push_tokens")
}

/// Notification: Registro de notificaciones enviadas
/// Sprint 12 - US-105
///
/// Este modelo almacena todas las notificaciones enviadas a usuarios,
/// tanto para historial como para tracking de notificaciones push.
///
/// Campos:
/// - userId: Usuario destinatario
/// - type: Tipo de notificaci贸n (ej: "habit_reminder", "task_due", etc.)
/// - title: T铆tulo de la notificaci贸n
/// - body: Cuerpo del mensaje
/// - data: Datos adicionales en formato JSON (ej: habitId, taskId)
/// - read: Si la notificaci贸n fue le铆da
/// - readAt: Fecha y hora en que se ley贸
/// - pushSent: Si se envi贸 notificaci贸n push
/// - pushSentAt: Fecha y hora de env铆o de push
/// - pushError: Mensaje de error si fall贸 el env铆o de push
///
/// ndices:
/// - (userId, read): Para listar notificaciones no le铆das
/// - (userId, createdAt DESC): Para listar todas las notificaciones ordenadas
model Notification {
  id         String    @id @default(uuid())
  userId     String
  type       String    @db.VarChar(50)
  title      String    @db.VarChar(200)
  body       String    @db.Text
  data       String?   @db.Text
  read       Boolean   @default(false)
  readAt     DateTime?
  pushSent   Boolean   @default(false)
  pushSentAt DateTime?
  pushError  String?   @db.Text
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([userId, createdAt(sort: Desc)])
  @@map("notifications")
}

/// Exercise: Ejercicios personalizados por usuario
/// Sprint 14 - US-125
///
/// Este modelo representa ejercicios creados por cada usuario para su entrenamiento.
/// Los ejercicios pueden ser de diferentes grupos musculares y se utilizan en rutinas.
///
/// Campos:
/// - name: Nombre del ejercicio (ej: "Press Banca", "Sentadilla")
/// - muscleGroup: Grupo muscular trabajado (enum MuscleGroup)
/// - notes: Notas adicionales sobre el ejercicio (t茅cnica, forma, etc.)
///
/// Restricciones:
/// - Un usuario no puede tener dos ejercicios con el mismo nombre
/// - ON DELETE CASCADE: Si se elimina el usuario, se eliminan sus ejercicios
///
/// ndices:
/// - userId: Para queries r谩pidas de ejercicios por usuario
model Exercise {
  id          String       @id @default(uuid())
  userId      String
  name        String       @db.VarChar(100)
  muscleGroup MuscleGroup?
  notes       String?      @db.Text
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  routineExercises RoutineExercise[]
  workoutExercises WorkoutExercise[]

  @@unique([userId, name])
  @@index([userId])
  @@map("exercises")
}

/// Routine: Rutinas de entrenamiento
/// Sprint 14 - US-125
///
/// Este modelo representa rutinas de entrenamiento creadas por usuarios.
/// Una rutina contiene m煤ltiples ejercicios con configuraci贸n espec铆fica.
///
/// Campos:
/// - name: Nombre de la rutina (ej: "Push Day", "Pull Day", "Piernas")
/// - description: Descripci贸n detallada de la rutina (opcional)
///
/// Relaciones:
/// - routineExercises: Ejercicios que componen la rutina (con orden y configuraci贸n)
/// - workouts: Sesiones de entrenamiento que usaron esta rutina
///
/// ndices:
/// - userId: Para listar rutinas por usuario
model Routine {
  id          String   @id @default(uuid())
  userId      String
  name        String   @db.VarChar(100)
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  routineExercises RoutineExercise[]
  workouts         Workout[]

  @@index([userId])
  @@map("routines")
}

/// RoutineExercise: Configuraci贸n de ejercicios en rutina
/// Sprint 14 - US-125
///
/// Este modelo representa la relaci贸n N:N entre Routine y Exercise,
/// con configuraci贸n espec铆fica de series, reps, peso y descanso.
///
/// Campos:
/// - order: Orden de ejecuci贸n del ejercicio en la rutina (1, 2, 3...)
/// - targetSets: Series sugeridas (opcional)
/// - targetReps: Repeticiones sugeridas (opcional)
/// - targetWeight: Peso sugerido en kg (opcional)
/// - restTime: Tiempo de descanso en segundos (opcional)
/// - notes: Notas espec铆ficas para este ejercicio en esta rutina
///
/// Restricciones:
/// - Un ejercicio solo puede aparecer una vez en una rutina (unique constraint)
/// - ON DELETE CASCADE: Si se elimina la rutina, se elimina su configuraci贸n
/// - ON DELETE RESTRICT: No se puede eliminar un ejercicio si est谩 en rutinas
///
/// ndices:
/// - routineId: Para listar ejercicios de una rutina
model RoutineExercise {
  id           String   @id @default(uuid())
  routineId    String
  exerciseId   String
  order        Int
  targetSets   Int?
  targetReps   Int?
  targetWeight Decimal? @db.Decimal(10, 2)
  restTime     Int?
  notes        String?  @db.Text

  routine  Routine  @relation(fields: [routineId], references: [id], onDelete: Cascade)
  exercise Exercise @relation(fields: [exerciseId], references: [id], onDelete: Restrict)

  @@unique([routineId, exerciseId])
  @@index([routineId])
  @@map("routine_exercises")
}

/// Workout: Sesi贸n de entrenamiento
/// Sprint 14 - US-125
///
/// Este modelo representa una sesi贸n individual de entrenamiento.
/// Puede estar basada en una rutina o ser libre (sin rutina).
///
/// Campos:
/// - routineId: Rutina utilizada (nullable si es entrenamiento libre)
/// - startTime: Fecha y hora de inicio del entrenamiento
/// - endTime: Fecha y hora de finalizaci贸n (null si est谩 en progreso)
/// - notes: Notas generales del entrenamiento (c贸mo te sentiste, etc.)
///
/// Estados:
/// - En progreso: endTime = null
/// - Finalizado: endTime != null
///
/// Restricciones:
/// - ON DELETE CASCADE: Si se elimina el usuario, se eliminan sus workouts
/// - ON DELETE SET NULL: Si se elimina la rutina, el workout queda como "libre"
///
/// ndices:
/// - (userId, startTime): Para listar entrenamientos por usuario ordenados por fecha
model Workout {
  id        String    @id @default(uuid())
  userId    String
  routineId String?
  startTime DateTime  @default(now())
  endTime   DateTime?
  notes     String?   @db.Text
  createdAt DateTime  @default(now())

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  routine          Routine?          @relation(fields: [routineId], references: [id], onDelete: SetNull)
  workoutExercises WorkoutExercise[]

  @@index([userId, startTime])
  @@map("workouts")
}

/// WorkoutExercise: Ejercicios ejecutados en sesi贸n
/// Sprint 14 - US-125
///
/// Este modelo representa los ejercicios realizados en una sesi贸n de entrenamiento.
/// Contiene informaci贸n espec铆fica de ese ejercicio en esa sesi贸n.
///
/// Campos:
/// - order: Orden de ejecuci贸n en el workout (1, 2, 3...)
/// - notes: Notas espec铆ficas del ejercicio en esta sesi贸n
/// - rpe: Rate of Perceived Exertion (1-10, opcional)
///
/// Relaciones:
/// - workoutSets: Series individuales realizadas en este ejercicio
///
/// Restricciones:
/// - ON DELETE CASCADE: Si se elimina el workout, se eliminan sus ejercicios
/// - ON DELETE RESTRICT: No se puede eliminar un ejercicio si est谩 en workouts
///
/// ndices:
/// - workoutId: Para listar ejercicios de un workout
model WorkoutExercise {
  id         String   @id @default(uuid())
  workoutId  String
  exerciseId String
  order      Int
  notes      String?  @db.Text
  rpe        Int?
  createdAt  DateTime @default(now())

  workout     Workout      @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  exercise    Exercise     @relation(fields: [exerciseId], references: [id], onDelete: Restrict)
  workoutSets WorkoutSet[]

  @@index([workoutId])
  @@map("workout_exercises")
}

/// WorkoutSet: Series individuales de ejercicio
/// Sprint 14 - US-125
///
/// Este modelo representa cada serie individual realizada en un ejercicio.
/// Almacena el peso, repeticiones y tiempo de descanso de cada serie.
///
/// Campos:
/// - setNumber: N煤mero de serie (1, 2, 3... secuencial por ejercicio)
/// - reps: Repeticiones realizadas en esta serie
/// - weight: Peso utilizado en esta serie
/// - weightUnit: Unidad del peso (kg o lbs)
/// - completed: Si la serie se complet贸 exitosamente
/// - restTime: Tiempo de descanso despu茅s de esta serie (segundos)
/// - notes: Notas espec铆ficas de esta serie (ej: "casi fallo", "muy f谩cil")
/// - timestamp: Momento exacto en que se complet贸 la serie
///
/// Restricciones:
/// - ON DELETE CASCADE: Si se elimina el workoutExercise, se eliminan sus series
///
/// ndices:
/// - workoutExerciseId: Para listar series de un ejercicio en un workout
model WorkoutSet {
  id                String     @id @default(uuid())
  workoutExerciseId String
  setNumber         Int
  reps              Int
  weight            Decimal    @db.Decimal(10, 2)
  weightUnit        WeightUnit @default(kg)
  completed         Boolean    @default(true)
  restTime          Int?
  notes             String?    @db.Text
  timestamp         DateTime   @default(now())

  workoutExercise WorkoutExercise @relation(fields: [workoutExerciseId], references: [id], onDelete: Cascade)

  @@index([workoutExerciseId])
  @@map("workout_sets")
}
